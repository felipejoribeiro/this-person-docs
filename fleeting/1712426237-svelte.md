---
id: 1712426237-svelte
aliases:
  - svelte
tags:
  - programming;
  - engineering;
---

# SVELTE FRAMEWORK

<span style="text-align: center; width: 100%; font-size: 0.75em">
    
Svelte is a declarative front-end component framework. It allows the programmer to create lean and fast web pages.

</span>

## Pressequisites

Before learning svelte it's important to know the basics of HTML, CSS, and JavaScript (specially the ES6+ fundamentals). You will need **NODE** (v16, for example) as well as a good text editor.

## Introduction

For creating a new project, use the following command:

```bash
npx degit sveltejs/template svelte-project
# or
npm init vite # then choose svelte. You will need node 18
```

The command will create all necessary files required for a basic svelte project:

The difference between then is the build tool. The first one uses rollup, the second one uses vite.

## Typescript integration

In case of vite it will prompt you if you want to use typescript. If you choose yes, it will create a typescript project for you.

In case of rollup, the template comes with a script to convert your project to typescript. it's inside the `scripts/` directory. Runnint `node scripts/setupTypeScript.js` and then `npm install` will convert your project to typescript.

Do not forget to install `@tsconfig/svelte` as well.

## Integrating eslint and prettier

For code formatting and linting, you can use eslint and prettier. You can install them with the following command:

```bash
yarn add --dev eslint prettier eslint-plugin-svelte eslint-plugin-prettier eslint-config-prettier
```

And then, check in the repositories for the `.eslintrc` and `.prettierrc` files to configure them.

And then add the `.prettierrc` file to the root of your project.

```json
{
  "plugins": ["prettier-plugin-svelte"],
  "overrides": [{ "files": "*.svelte", "options": { "parser": "svelte" } }],
  "tabWidth": 2,
  "semi": true,
  "printWidth": 100,
  "singleQuote": true,
  "trailingComma": "es5"
}
```

And add this to `.eslintrc.cjs`:

```cjs
module.exports = {
  root: true,
  extends: ["eslint:recommended", "plugin:svelte/recommended", "prettier"],
  parserOptions: {
    sourceType: "module",
    ecmaVersion: 2020,
    extraFileExtensions: [".svelte"],
  },
  env: {
    browser: true,
    es2017: true,
    node: true,
  },
};
```

And remember to always use the `lang="ts"` attribute in the `<script>` tag of your svelte components or else there will be type checking problems.

## Integration with neovim

For neovim integration you will need to install the following plugins:

```bash
yarn add --dev typescript-svelte-plugin
```

Then, add this to your tsconfig.json:

```json
{
  "plugins": [{ "name": "typescript-svelte-plugin" }]
}
```

## Entry point

The entry point of a svelte project is the `src/main.ts` file. It's porpuse is to render the main component of the project to a specified element in the DOM (normaly the `body` tag with `document.body`), if your entire app is a **svelte** project.

```typescript
import App from "./App.svelte";

const app = new App({
  target: document.body,
});

export default app;
```

Which will render the `App` component in the `body` tag of the HTML file.

## Svelte components

A svelte component is defined inside a file. It has a `<styles>` tag for the styles, a `<script>` tag for the logic, and the **markup** html language that determines the content of the component which can be added anywhere in the file. These tags go directly in the `.svelte` file.

> If you check in the browser inspectr you will see all `tags` inside the main component inside body, which was defined as the entry point.

You can add a `<style>` tag to your svelte file, to add styles in your component without poluting the global scope. Another option is to use **CSS** files to style your components as well. That can be done by adding the `src` attribute to the `<style>` tag.

```svelte
<style src="./table.css"></style>
```

But it's advised to keep the styles inside the component file.

## Inporting components

In Svelte you can add components to a project by creating a `.svelte` file, and then you can import this in another svelte files, like so:

```svelte
<script>
  import MyComponent from "./MyComponent.svelte";
</script>

<MyComponent />
```

> It's recomended to always make upercase the first letter of your component name, to differentiate it from vanilla html tags.

## Direct html inserts

You can add direct html code to your svelte component by using the `{@html}` tag. This will render the html code as it is, without any processing.

```svelte
<script>
  let html = "<h1>Hello World</h1>";
</script>
{@html html}
```

Only advised if you know the provenance of the html code, as it can be a security risk. So allowing user input to be rendered as html directly in another user's browser is a big no-no.

## Props

You can pass props to a component by using the `export` keyword in the script tag of the component. This will make the prop available to the parent component.

```svelte
<script>
  export let name;
</script>

<h1>Hello {name}</h1>
```

And then you can use the component like so:

```svelte
<script>
  import MyComponent from "./MyComponent.svelte";
</script>

<MyComponent name="John Doe" />
```

Interestingly enough, you can omite the prop name if the variable name is the same as the prop name. Like so:

```svelte
<script>
  import MyComponent from "./MyComponent.svelte";
  const name = "John Doe";
</script>

<MyComponent {name} />
```

And you can access the props in the parent component by using the `$$props` sign before the prop name. And even unnamed props can be accessed by using the `$$restProps` variable.

```svelte
<script>
  export let myName;
  export let yourName;

  console.log($$props)
  // { myName: "John Doe", yourName: "Jane Doe" }
  console.log($$restProps)
  // { class: "my-class", id: "my-id", etc: "?..." }
</script>
```

> Be carefull with this feature, as it can lead to performance issues.

## Dynamic classes

You can add classes to a component by using the `class` directive. This will add the class to the component if the condition is true.

```svelte
<script>
  let isActive = true;
  let shadow = true;
</script>

<div
  class:active={isActive}
  class:shadow
>
  Hello World
</div>
```

In this case, the classes `active` and `shadow` will be added to the `div` tag if their variables is true. Props without default values are obligatory. You can add a `undefined` initial value, if you want it to not be obligatory but doesn't want to specify a default value.

## Conditional rendering

You can conditionally render a component by using the `if` directive. This will render the component if the condition is true.

```svelte
<script>
  let isActive = true;
</script>

{#if isActive}
  <div>Hello World</div>
{:else if isActive === undefined}
  <div>not defined</div>
{:else}
  <div>Goodbye World</div>
{/if}
```

## Looping

You can loop over an array of items by using the `each` directive. This will render the component for each item in the array.

```svelte
<script>
  let items = ["one", "two", "three"];
</script>

{#each items as item, index (item)}
  <div>{item}</div>
  <p>{index}</p>
{/each}
```

Notice the `(item)` after the `each` directive. This is the key that will be used to identify the item in the loop, which is very importante for performance reasons as well to avoid bugs. If you don't provide the key, svelte will treat the list index as not unique, and will not be able to identify the items in the list and changes to each element will not be bind to the correct element.

## Event handling

You can handle events by using the `on` directive. This will call the function when the event is triggered.

```svelte
<script>
  function handleClick(event) {
    console.log(event);
    console.log("Hello World");
  }
</script>

<button on:click={handleClick}>Click me</button>
```

## State management

The following example doesn't work:

```svelte
<script>
  count = 0;
  string = `my count is ${0} and it doesn't update`

  function increment() {
    count +=1
  }
</script>

<button on:click={increment}>Click</button>
<h3>{string}</h3>
```

When the user clicks, the `string` doesn't update. The reason is that only count was changed. It doesn't affect other state elements. To make it work you can use a **reactive statement**:

```svelte
<script>
  count = 0;
  $: string = `my count is ${0} and it doesn't update`
  $: if (count > 2) {
    string = `my count is ${0}, which is bigger than 2`
  }

  function increment() {
    count +=1
  }
</script>

<button on:click={increment}>Click</button>
<h3>{string}</h3>
```

Now, this should work as expected. Remember that only the state that is present inside the reactive statement will trigger the statement. If you have a function for example, that references state, and you call the function inside the reactive statement, without referencing the state, it will not trigger it. A good solution to this is making all state be input arguments of the function, and when calling it in the reactive statement, you would have to reference then in the reactive statement. The order of the react statements is important as well. What is up in the code will be run first.

## Component children

A component can have children elements. To reference then you can use the `<slot/>` native component. It references everything that is child of your component. It can represent a fallback as well. which can be done like so:

```svelte
<div>
  <slot>Fallback stuff</slot>
</div>
```

In this case, the slot component will be substituted by the component's children, if no children is provided it will be substituted by what is inside.
